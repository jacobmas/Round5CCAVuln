
# This file was *autogenerated* from the file /Users/jma7/Downloads/Round5/Supporting_Documentation/Scripts/Correctness/correctness.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_852 = Integer(852); _sage_const_162 = Integer(162); _sage_const_490 = Integer(490); _sage_const_8 = Integer(8); _sage_const_618 = Integer(618); _sage_const_136 = Integer(136); _sage_const_500 = Integer(500); _sage_const_650 = Integer(650); _sage_const_200 = Integer(200); _sage_const_508 = Integer(508); _sage_const_470 = Integer(470); _sage_const_520 = Integer(520); _sage_const_64 = Integer(64); _sage_const_43 = Integer(43); _sage_const_270 = Integer(270); _sage_const_740 = Integer(740); _sage_const_114 = Integer(114); _sage_const_170 = Integer(170); _sage_const_238 = Integer(238); _sage_const_594 = Integer(594); _sage_const_318 = Integer(318); _sage_const_550 = Integer(550); _sage_const_590 = Integer(590); _sage_const_420 = Integer(420); _sage_const_9 = Integer(9); _sage_const_700 = Integer(700); _sage_const_400 = Integer(400); _sage_const_192 = Integer(192); _sage_const_212 = Integer(212); _sage_const_2p0 = RealNumber('2.0'); _sage_const_720 = Integer(720); _sage_const_180 = Integer(180); _sage_const_600 = Integer(600); _sage_const_440 = Integer(440); _sage_const_350 = Integer(350); _sage_const_256 = Integer(256); _sage_const_250 = Integer(250); _sage_const_370 = Integer(370); _sage_const_13 = Integer(13); _sage_const_12 = Integer(12); _sage_const_11 = Integer(11); _sage_const_10 = Integer(10); _sage_const_0p = RealNumber('0.'); _sage_const_800 = Integer(800); _sage_const_320 = Integer(320); _sage_const_640 = Integer(640); _sage_const_620 = Integer(620); _sage_const_128 = Integer(128); _sage_const_104 = Integer(104); _sage_const_540 = Integer(540); _sage_const_570 = Integer(570); _sage_const_670 = Integer(670); _sage_const_750 = Integer(750); _sage_const_636 = Integer(636); _sage_const_300 = Integer(300); _sage_const_220 = Integer(220); _sage_const_450 = Integer(450)# NOTE: The below code needs to be run in the SAGE Jupyter Notebook


####################################################################
##       ESTIMATION OF FAILURE PROBABILITIES IN ROUND5            ##
####################################################################
## This SAGE code estimates the probability of decryption failures
## in Round5 parameters, both for ones that use error correction
## (and thus use polynomial multiplication modulo x^(n+1)-1 in 
## combination with balanced sparse-ternary secrets), and for ones
## that do not use it (thus using polynomial multiplication modulo
## \Phi_{n+1}(x) = x^n + x^(n-1) + ... + 1.)
## 
## In order to obtain accurate estimates (as much as possible), 
## explicit high-precision convolutions are used.
##
## INPUT: Round5 parameters d, n, h, 
##                          log_2(q), log_2(p), log_2(t),
##                          logb, \overline{n}, \overline{m},
##                          f, mu
##        A number of exemplary "high failure" Round5 parameters
##        are provided as part of this code to demonstrate how it works.
##
## OUTPUT: The final output is a plot of how the following two 
##         probabilities behave with increasing Hamming weight (h) 
##         (a) the probability of at least one error occurring,
##         (b) the probability of at least two errors occurring.
##
## The functions below provide further intermediate output that are
## useful in themselves for analyzing the system. These include 
## the overall error distribution for a given parameter set, i.e.,
## the probability of at least 'i' errors occurring, for 1<=i<=mu.
#####################################################################
    


RRR = RealField(_sage_const_256 ) # 150 bits precision, increase if necessary...

#
# Convolve two given probability distributions A and B, 
# represented as lists, modulo q
#
def myconv(A,B,q):
    C = [_sage_const_0  for _ in range(q) ]
    for i in range(q):
        for j in range(q):
            # restrict support to Z_q
            k = (i+j)%q
            C[k] = C[k] + A[i] * B[j]
    return C

#
# Iteratively convolve a given probability distribution A,
# that has support in Z_q, with itself, 'p' times.
#
def myconvpower(A,p,q):
    nb = p.nbits()
    result = [_sage_const_0  for _ in range(q)]
    result[_sage_const_0 ]=_sage_const_1 
    for bit in range(nb-_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ):
        if bit < nb - _sage_const_1 :
            result = myconv(result,result,q)
        if (p//_sage_const_2 **bit)%_sage_const_2  == _sage_const_1 :
            result = myconv(result,A,q)
    return result

#
# Compute the error distribution for
# for a given set of Round5 parameters. 
# ASSUMPTION: Rounding errors are treated as if sampled from a 
# uniform, bounded distribution. Any dependence between the secret
# and the rounding error is ignored.
#   
def errprobsconv(d, n, h, q, p, t, logb, nbar, mbar, f, mu):
       
    # Sanity check
    if (not (q/_sage_const_2 /p) in ZZ) or (not (q/_sage_const_2 /t) in ZZ):
        print 'q/2p or q/2t not in ZZ. Abort.'
        return
    
    
    # Uniform error distribution over -q/2p...q/2p
    # represents error introduced when rounding from Z_q to Z_p
    Ep = [_sage_const_0  for _ in range(q)]
    for i in range(q/_sage_const_2 /p):
        Ep[i]=RRR(p/q)
    Ep[q/_sage_const_2 /p]=RRR(p/_sage_const_2 /q)
    Ep[q-q/_sage_const_2 /p]=RRR(p/_sage_const_2 /q)
    for i in range(q-q/_sage_const_2 /p+_sage_const_1 ,q):
        Ep[i]=RRR(p/q)
    
    
    # Uniform error distribution over -q/2t...q/2t
    # represents error introduced when rounding from Z_q to Z_p, then to Z_t
    Et = [_sage_const_0  for _ in range(q)]
    for i in range(q/_sage_const_2 /t):
        Et[i]=RRR(t/q)
    Et[q/_sage_const_2 /t]=RRR(t/_sage_const_2 /q)
    Et[q-q/_sage_const_2 /t]=RRR(t/_sage_const_2 /q)
    for i in range(q-q/_sage_const_2 /t+_sage_const_1 ,q):
        Et[i]=RRR(t/q)
    

    # Compute the distribution of the error term (j_B*r - s*j_U), 
    # where s, r are the secret-keys, and j_B, j_U are the errors 
    # introduced while computing the public-keys of Alice and Bob
    # respectively; see Section 2.8, 2.8.3 of the specification.
    # ASSUMPTION: Any dependencies between j_B and s, j_U and r ignored.
    conv_fold = _sage_const_2 *h
    EpH = myconvpower(Ep,conv_fold,q)
    
    
    # Compute the distribution of (j_B*r - s*j_U) + j_v
    EpHt = myconv(EpH,Et,q)
    
    
    # Return the error distribution
    return (EpH,EpHt)


#
# Compute (bit) failure probabilities for Round5 parameters,
# (a) ring parameters with error correction,
# (b) ring parameters without error correction,
# (c) non-ring parameters.
#
def errprobs(d, n, h, logq, logp, logt, logb, nbar, mbar, f, mu):
    print "In errorprobs, n={0}".format(n)
    # Round5 moduli
    q = _sage_const_2 **logq; p = _sage_const_2 **logp; t = _sage_const_2 **logt;
    
    # Get the (rounding) error distribution for given parameters,
    # both the intermediate (before adding j_v) and the final
    # distribution (after adding j_v)
    (EpH,EpHt) = errprobsconv(d, n, h, q, p, t, logb, nbar, mbar, f, mu)
        
    
    # Decryption failure/success thresholds
    # Decryption fails if error terms \in [up_fail, down_fail)
    up_fail = (q + (_sage_const_1 <<logb)) // (_sage_const_1 <<(logb+_sage_const_1 ))
    down_fail = (q*( (_sage_const_1 <<(logb+_sage_const_1 )) - _sage_const_1 ) + (_sage_const_1 <<logb)) // (_sage_const_1 <<(logb+_sage_const_1 ))
    
    
    # Sanity check
    if logb==_sage_const_1 :
        assert up_fail==(q//_sage_const_4 )
        assert down_fail==(_sage_const_3 *q//_sage_const_4 )
    
    
    ##########################################################################
    # Error probability for ring parameters with and without error correction.
    # 
    # For both cases, polynomial multiplication modulo x^(n+1)-1 must be done,
    # hence computing the error distribution in that case, i.e., distribution
    # of (j_B*r - s*j_U) + j_v is always necessary, irrespective of whether 
    # f=0 or f>0.
    #
    # ASSUMING that dependencies between coefficients of the overall error term
    # (j_B*r - s*j_U) + j_v are ignored, the distribution can be approximated 
    # by a binomial distribution with some bit error probability 
    # bfp = Pr[ up_fail <= XX < down_fail ], 
    # where Pr[ XX = x ] = EpHt[x].
    #
    # In more generic terms,
    # let Pcond[a] = Pr[ up_fail <= XX - a mod q < down_fail ],
    # where Pr[ XX = x ] = EpHt[x].
    ##########################################################################
    
    # Init Pcond
    Pcond = [_sage_const_0  for _ in range(q)]
    
    # Compute Pcond[a], differentiating between the two types of ring parameters.
    for a in range(q):
        for i in range(q):
            if f==_sage_const_0  and n==d:
                ##########################################################################
                # Error probability for ring parameters without error correction, 
                # i.e., polynomial multiplication modulo x^n+x^(n-1)+...+1).
                # The above multiplication involves one modulo x^(n+1)-1, followed by a 
                # subtraction of the highest order coefficient a = c_n(s,e) from all the
                # other coefficients, see Sec. 2.8.4 of the specification.
                # Thus, compute Pcond[a] = Pr[ up_fail <= XX - a mod q < down_fail ],
                # where Pr[ XX = x ] = EpHt[x]
                ##########################################################################
        
                coeff = (i+q-a)%q
            
            elif f>_sage_const_0  or n==_sage_const_1 :
                ##############################################################################
                # Error probability for ring parameters with error correction; i.e., f>0
                # (polynomial multiplication modulo x^(n+1)-1), or for non-ring parameters;
                # i.e., n==1, where a similar independence assumption is made.
                # 
                # Note that here the highest order coefficient a = c_n(s,e) 
                # does not influence the other coefficients.
                #
                # Therefore, as mentioned above, bfp = Pr[ up_fail <= XX < down_fail ], 
                # where Pr[ XX = x ] = EpHt[x].
                ##############################################################################
                coeff = i%q               # same as coeff=i
                assert coeff==i
            # Finally, compute Pcond[a]
            if coeff>=up_fail and coeff<down_fail:
                Pcond[a] = Pcond[a] + EpHt[i]

    # Compute the overall error distribution of (j_B*r - s*j_U) + j_v that can be approximated
    # by a Binomial distribution, with additional influence by the a=c_n(s,e) term in the case
    # f==0, i.e., in parameters without error correction.
    
    # Number of errors that occur during decryption
    ee = [ _sage_const_0  for i in range(mu+_sage_const_1 ) ]
    for k in range(mu+_sage_const_1 ):
        # Note that below, for the case f>0, Pcond[a] always = Pcond[0]
        ee[k]=sum( binomial(mu,k)*(Pcond[a]**k)*((_sage_const_1 -Pcond[a])**(mu-k))*EpH[a] for a in range(q) )
    # Overall error distribution
    eetail = [_sage_const_0  for _ in range(mu+_sage_const_1 )]
    eetail[-_sage_const_1 ]=ee[-_sage_const_1 ]
    for i in range(mu-_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ):
        eetail[i]=eetail[i+_sage_const_1 ]+ee[i]
    
    
    # Compute the bit failure probability
    if f==_sage_const_0  and n==d:
        # additional influence due to subtraction of a=c_n(s,e) must be accounted for.
        bfp = eetail[_sage_const_1 ]/mu
    else:
        # no influence from a=c_n(s,e)
        bfp = sum(EpHt[up_fail:down_fail])
    if n==d and f>_sage_const_0 :  assert bfp==Pcond[_sage_const_0 ]         # Sanity check        
        
    
    # Compute the final error probability after correcting 'f' errors
    ffp = _sage_const_0p 
    if f>_sage_const_0 :
        ffp = sum( binomial(mu, j) * (bfp**j) * ((_sage_const_1  - bfp)**(mu - j)) for j in range(f + _sage_const_1 , mu))
    else:
        ffp = None
        
    # Return the error distribution, the bit failure probability, 
    # and the post-error-correction failure probability
    return (eetail,bfp,ffp)


#
# For a given set of Round5 parameters, compute the probability of 
# (a) at least 1 error, (b) at least two errors,
# (c) overall error distribution.
#
def getfail(param_name, d, n, h, logq, logp, logt, logb, nbar, mbar, f, mu):
    
    (etail, bfp, ffp) = errprobs(d, n, h, logq, logp, logt, logb, nbar, mbar, f, mu)
    
    # Probability of at least one error
    log_1fp = log(etail[_sage_const_1 ],_sage_const_2p0 )
    
    # Probability of at least 2 errors
    log_2fp = log(etail[_sage_const_2 ],_sage_const_2p0 )
    
    return (log_1fp,log_2fp,etail,ffp)


def showfail(param_name, d, n, h, logq, logp, logt, logb, nbar, mbar, f, mu):
    (log_1fp,log_2fp,etail,ffp) = getfail(param_name, d, n, h, logq, logp, logt, logb, nbar, mbar, f, mu)
    print "\n\nParameter",param_name,"has failure probability (before error correction):\t", log_1fp
    if ffp:               print "Post-XEf failure probability:\t",log(ffp,_sage_const_2p0 ),"\n"
    for i in range(_sage_const_6 ):    print "Parameter",param_name,"-- Probability of at least",i,"errors:\t", log(etail[i],_sage_const_2p0 )
    return


#############################################################################################################


print "\n\nWarning: Please make sure this script is being run in the SAGE Jupyter notebook.\nIf not, then please exit (Ctrl+C) and try again.\n\n"


# Print failure rates of Round5 parameters
# Uncomment parameters to run them.

# Be warned that parameters with q>2^15 take *a long time* to compute

# Round5.KEM

# Round5 ring parameters without error correction
showfail("R5ND_1KEM_0c",_sage_const_618 ,_sage_const_618 ,_sage_const_104 ,_sage_const_11 ,_sage_const_8 ,_sage_const_4 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_128 )
#showfail("R5ND_3KEM_0c",786,786,384,13,9,4,1,1,1,0,192)
#showfail("R5ND_5KEM_0c",1018,1018,428,14,9,4,1,1,1,0,256)

# Round5 ring parameters with error correction
showfail("R5ND_1KEM_5c",_sage_const_490 ,_sage_const_490 ,_sage_const_162 ,_sage_const_10 ,_sage_const_7 ,_sage_const_3 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_5 ,_sage_const_318 )
#showfail("R5ND_3KEM_5c",756,756,242,12,8,2,1,1,1,5,410)
#showfail("R5ND_5KEM_5c",940,940,414,12,8,2,1,1,1,5,490)

# Round5 non ring parameters, without error correction
showfail("R5N1_1KEM_0c",_sage_const_594 ,_sage_const_1 ,_sage_const_238 ,_sage_const_13 ,_sage_const_10 ,_sage_const_7 ,_sage_const_3 ,_sage_const_7 ,_sage_const_7 ,_sage_const_0 ,_sage_const_43 )
#showfail("R5N1_3KEM_0c",881,1,238,13,10,7,3,8,8,0,64)
#showfail("R5N1_5KEM_0c",1186,1,712,15,12,7,4,8,8,0,64)

# Round5 PKE

# Round5 ring parameters without error correction
#showfail("R5ND_1PKE_0c",586,586,182,13,9,4,1,1,1,0,128)
showfail("R5ND_3PKE_0c",_sage_const_852 ,_sage_const_852 ,_sage_const_212 ,_sage_const_12 ,_sage_const_9 ,_sage_const_5 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_0 ,_sage_const_192 )
#showfail("R5ND_5PKE_0c",1170,1170,222,13,9,5,1,1,1,0,256)

# Round5 ring parameters with error correction
showfail("R5ND_1PKE_5c",_sage_const_508 ,_sage_const_508 ,_sage_const_136 ,_sage_const_10 ,_sage_const_7 ,_sage_const_4 ,_sage_const_1 ,_sage_const_1 ,_sage_const_1 ,_sage_const_5 ,_sage_const_318 )
#showfail("R5ND_3PKE_5c",756,756,242,12,8,3,1,1,1,5,410)
#showfail("R5ND_5PKE_5c",940,940,414,12,8,3,1,1,1,5,490)

# Round5 non ring parameters, without error correction
showfail("R5N1_1PKE_0c",_sage_const_636 ,_sage_const_1 ,_sage_const_114 ,_sage_const_12 ,_sage_const_9 ,_sage_const_6 ,_sage_const_2 ,_sage_const_8 ,_sage_const_8 ,_sage_const_0 ,_sage_const_64 )
#showfail("R5N1_3PKE_0c",876,1,446,15,11,7,3,8,8,0,64)
#showfail("R5N1_5PKE_0c",1217,1,462,15,12,9,4,8,8,0,64)



############################################################################################################



# Round5 "high failure" parameters. Plot the probabilities of
# at least one error, and at least 2 errors to show that the
# use of different reduction polynomials and balanced secrets
# allows the use of an independence assumption and thus error
# correction in Round5.


# Round5 high failure parameters


name="R5_highfail"; 
d=_sage_const_800 ; n=_sage_const_800 ; 
# Other Round5 parameters, these stay fixed for the 
# "high-failure" parameters considered. The Hamming 
# weight is varied (see below, hammwts[]) to show
# how the failure rate depends on it
logq=_sage_const_11 ; logp=_sage_const_7 ; logt=_sage_const_4 ; 
logb=_sage_const_1 ; nbar=_sage_const_1 ; mbar=_sage_const_1 ; mu=_sage_const_128 ;
hammwts = [ _sage_const_170 , _sage_const_180 , _sage_const_200 , _sage_const_220 , _sage_const_250 , _sage_const_270 , _sage_const_300 , _sage_const_320 , _sage_const_350 , _sage_const_370 , _sage_const_400 , _sage_const_420 , _sage_const_440 , _sage_const_450 , _sage_const_470 , _sage_const_500 , _sage_const_520 , _sage_const_540 , _sage_const_550 , _sage_const_570 , _sage_const_590 , _sage_const_600 , _sage_const_620 , _sage_const_640 , _sage_const_650 , _sage_const_670 , _sage_const_700 , _sage_const_720 , _sage_const_740 , _sage_const_750  ]


# List of probabilities of at least one error occuring, when
# \xi=\Phi_{n+1} is the reduction polynomial used in encryption
# and decryption, as in Round5 parameters with no error correction
onefps_phi = []
# List of probabilities of at least two errors occuring, when
# \xi=\Phi_{n+1} is the reduction polynomial used in encryption
# and decryption, as in Round5 parameters with no error correction
twofps_phi = []


# List of probabilities of at least one error occuring, when
# \xi=N_{n+1} is the reduction polynomial used in encryption
# and decryption, as in Round5 parameters using error correction
onefps_ntru = []
# List of probabilities of at least two errors occuring, when
# \xi=N_{n+1} is the reduction polynomial used in encryption
# and decryption, as in Round5 parameters using error correction
twofps_ntru = []


for h in hammwts:
    print "Computing failure for h=",h
    
    # f=0, reduction polynomial \xi=\Phi_{n+1}
    # onefp_phi = Probability of at least one error
    # twofp_phi = Probability of at least two errors
    # errtail   = Tail distribution of decryption errors
    # ffp       = Post-error-correction failure rate
    (onefp_phi, twofp_phi, errtail, ffp) = getfail(name, d, n, h, logq, logp, logt, logb, nbar, mbar, _sage_const_0 , mu)
    onefps_phi.append(onefp_phi)
    twofps_phi.append(twofp_phi)

    # f>0, reduction polynomial \xi=N_{n+1}
    # f=0, reduction polynomial \xi=\Phi_{n+1}
    # onefp_ntru = Probability of at least one error
    # twofp_ntru = Probability of at least two errors
    # ntruerrtail= Tail distribution of decryption errors
    # ffp        = Post-error-correction failure rate
    (onefp_ntru, twofp_ntru, ntruerrtail, ffp) = getfail(name, d, n, h, logq, logp, logt, logb, nbar, mbar, _sage_const_5 , mu)
    onefps_ntru.append(onefp_ntru)
    twofps_ntru.append(twofp_ntru)


show(
list_plot(zip(hammwts, onefps_phi),plotjoined=True,linestyle="-",color='red')+
list_plot(zip(hammwts, twofps_phi),plotjoined=True,linestyle="-.",color='red')+
list_plot(zip(hammwts, onefps_ntru),plotjoined=True,linestyle="-",color='green')+
list_plot(zip(hammwts, twofps_ntru),plotjoined=True,linestyle="-.",color='green'),
axes_labels=["$h$","Failure rate ($log_2$)"],
figsize=_sage_const_12 
)

##################################################################################

# Comparison with failure rates of actual simulated parameters,
# using data obtained from runFailureAnalysis.sh


# Number of simulations that are run,
# this is part of the output of runFailureAnalysis.sh
# repeat = 1000000


# Below data can be obtained using the output of runFailureAnalysis.sh

# IMPORTANT, how to compute phiOneFailures[], phiTwoFailures[], 
#                           ntruOneFailures[], ntruTwoFailures[] below:
# 
# runFailureAnalysis.sh outputs a vector of bit error counts for each 
# "high-failure" Round5 parameter set that is simulated. For example, 
# on running, the output of runFailureAnalysis.sh is of the form:
#
# R5ND_0KEM_<HIGHFAILUREPARAMETERSET> failed <NUMBEROFTIMES> out of <REPEAT> times (<FAILURERATE>%)
# Bit error counts: <BITERRORCOUNTVECTOR>
#
# For the i'th R5ND_0KEM_0fail_phi_<IDX> parameter set considered,
# the number of times at least one error occurred is
# phiOneFailures[i] = BITERRORCOUNTVECTOR[1] + BITERRORCOUNTVECTOR[2] + ... + BITERRORCOUNTVECTOR[n-1]
#
# and the number of times at least two errors occurred is
# phiTwoFailures[i] = BITERRORCOUNTVECTOR[2] + BITERRORCOUNTVECTOR[3] + ... + BITERRORCOUNTVECTOR[n-1]
#
# Similarly, for the i'th R5ND_0KEM_xfail_ntru_<IDX> parameter set considered,
# the number of times at least one error occurred is
# ntruOneFailures[i] = BITERRORCOUNTVECTOR[1] + BITERRORCOUNTVECTOR[2] + ... + BITERRORCOUNTVECTOR[n-1]
#
# and the number of times at least two errors occurred is
# ntruTwoFailures[i] = BITERRORCOUNTVECTOR[2] + BITERRORCOUNTVECTOR[3] + ... + BITERRORCOUNTVECTOR[n-1]


# Hamming weights simulated for parameters with 
# reduction polynomial \xi=\Phi_{n+1}, should
# be the same as hammwts[] above
# phiHammingWeights = []          # <-- copy from runFailureAnalysis.sh's output
# assert len(phiHammingWeights)==len(hammwts) and sorted(phiHammingWeights)==sorted(hammwts)

# Number of simulations where *at least one* error occurred
# phiOneFailures = []             # <-- compute using runFailureAnalysis.sh's output, see above

# Number of simulations where *at least two* errors occurred
# phiTwoFailures = []             # <-- compute using runFailureAnalysis.sh's output, see above

# Probabilities of at least one error in the simulations run 
# onefps_sim_phi = [log(phiOneFailures[i]/repeat,2.) for i in range(len(phiOneFailures))]
# Probabilities of at least two errors in the simulations run
# twofps_sim_phi = [log(phiTwoFailures[i]/repeat,2.) for i in range(len(phiTwoFailures))]


# Hamming weights simulated for parameters with 
# reduction polynomial \xi=N_{n+1}, should
# be the same as hammwts[] above
# ntruHammingWeights = []         # <-- copy from runFailureAnalysis.sh's output
# assert len(ntruHammingWeights)==len(hammwts) and sorted(ntruHammingWeights)==sorted(hammwts)

# Number of simulations where *at least one* error occurred
# ntruOneFailures = []            # <-- compute using runFailureAnalysis.sh's output, see above

# Number of simulations where *at least two* errors occurred
# ntruTwoFailures = []            # <-- compute using runFailureAnalysis.sh's output, see above

# Probabilities of at least one error in the simulations run 
# onefps_sim_ntru = [log(ntruOneFailures[i]/repeat,2.) for i in range(len(ntruOneFailures))]
# Probabilities of at least two errors in the simulations run
# twofps_sim_ntru = [log(ntruTwoFailures[i]/repeat,2.) for i in range(len(ntruTwoFailures))]


# Plot probabilities of at least one and at least two errors, for the
# cases that reduction polynomial = \Phi_{n+1} and N_{n+1}. Plot
# estimated values next to simulated ones.

#show(
#list_plot(zip(hammwts, onefps_phi),plotjoined=True,linestyle="-",color='red')+
#list_plot(zip(hammwts, twofps_phi),plotjoined=True,linestyle="-.",color='red')+
#list_plot(zip(hammwts, onefps_ntru),plotjoined=True,linestyle="-",color='green')+
#list_plot(zip(hammwts, twofps_ntru),plotjoined=True,linestyle="-.",color='green')+
#list_plot(zip(hammwts[3:],onefps_sim_phi),color='black',marker='D',size=40)+
#list_plot(zip(hammwts[3:],twofps_sim_phi),color='black',marker='D',size=40)+
#list_plot(zip(hammwts[3+2:],onefps_sim_ntru),color='black',marker='D',size=40)+
#list_plot(zip(hammwts[3+8:],twofps_sim_ntru),color='black',marker='D',size=40),
#axes_labels=["$h$","Failure rate ($log_2$)"],
#axes=True,
#figsize=15
#)

###################################################################################

